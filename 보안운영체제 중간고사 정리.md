# 보안운영체제 중간고사 정리



## 1장 01프로세스



### 사용자 가시 레지스터 : 사용자가 운영체제와 사용자 프로그램을 이용해 정보 변경 가능

- 데이터 레지스터 (DR, Data Register) : 함수 연산에 필요한 데이터를 저장한다. 값,문자 등을 저장하므로 산술 연산이나 논리 연산에 사용하며, 연산 결과로 플래그 값을 저장한다.
- 주소 레지스터 (AR,Address Register) : 주소나 유효 주소를 계산하는 데 필요한 주소의 일부분을 저장한다. 주소 레지스터에 저장한 값(값 데이터)을 사용하여 산술 연산을 할 수 있다.
  - 기준 주소 레지스터 : 프로그램을 실행할 때 사용하는 기준 주소 값을 저장한다. 기준 주소는 하나의 프로그램이나 일부처럼 서로 관련 있는 정보를 저장하며, 연속된 저장 공간을 지정하는 데 참조할 수 있는 주소이다. 따라서 기준 주소 레지스터는 페이지나 세그먼트처럼 블록화된 정보에 접근하는데 사용한다.
  - 인덱스 레지스터 : 유효 주소를 계산하는 데 사용하는 주소 정보를 저장한다.
  - 스택 포인터 레지스터 : 메모리에 프로세서 스택을 구현하는 데 사용한다. 많은 프로세서와 주소 레지스터를 데이터 스택 포인터와 큐 포인터로 사용한다. 보통 반환 주소, 프로세서 상태 정보, 서브루틴의 임시 변수를 저장한다.



### 사용자 불가시 레지스터 : 사용자가 정보를 변경할 수 없는 레지스터이다. 프로세서의 상태와 제어를 관리

- 프로그램 카운터 (PC,Program Counter) : 다음에 실행할 명령어의 주소를 보관하는 레지스터이다 
- 명령어 레지스터 (IR,Instruction Register) : 현재 실행하는 명령어를 보관하는 레지스터이다.
- 누산기 (ACC,ACCumulator) : 데이터를 일시적으로 저장하는 레지스터이다.
- 메모리 주소 레지스터 (MAR,Memory Address Register) : 프로세서가 참조하려는 데이터의 주소를 명시하여 메모리에 접근하는 버퍼 레지스터 이다.
- 메모리 버퍼 레지스터 (MBR,Memory Buffer Regisrer) : 프로세서가 메모리에서 읽거나 메모리에 저장할 데이터 자체를 보관하는 버퍼 레지스터이다.  메모리 데이터 레지스터  (MDR,Memory Data Register)라고도 한다.



### 메모리 계층 구조 

> 1950~1960년대 너무 비싼 메인 메모리의 가격 문제 떄문에 제안한 방법으로 메모리를 계층적으로 구성하여 비용,속도,용량,접근시간 등을 상호 보완

- 레지스터 : 프로세서가 사용한 데이터를 보관하는 가장 빠른 메모리
- 캐시 : 프로세서의 속도 차이를 보완하는 메모리
- 메인 메모리 : 프로세서 외부에  있으면서 프로세서에서 수행할 프로그램과 데이터를 저장하거나 프로세서에서 처리한 결과를 저장한다 주기억장치 or 1차 기억장치라고 한다. DRAM을 많이 이용
- 보조기억장치

> 레지스터,캐시,메인 메모리는 프로세서가 프로그램과 데이터에 직접 접근할 수 있다.
>
> 보조기억장치는 프로그램과 데이터를 메인 메모리에 옮겨야 실행 할 수 있다.



### 캐시

- 프로세서 내부나 외부에 있으며, 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리의 속도 차이를 보완하는 고속 버퍼

  - 메인 메모리에서 **데이터를 블록 단위** 로 가져와 프로세서에 **워드 단위** 로 전달하여 속도를 높임

  > 메인 메모리와 크기가 동일한 블록 여려 개로 구성되는데, 보통 8~64바이트 정도 크기의 블록으로 구성

  - 데이터가 이동하는 통로(대역폭)를 확대하여 프로세서와 메인 메모리의 속도 차이를 줄임

![주석 2019-10-12 143129](https://user-images.githubusercontent.com/37978105/66697499-1ee40e00-ed11-11e9-9d0b-f42d107eb73c.png)



- 캐시의 성는은 작은 용량의 캐시에 프로세서가 이후 참조할 정보가 얼마나 들어 있느냐로 좌우됨
  - 캐시 적중(캐시 히트) : 프로세서가 참조하려는 정보가 있을 때
  - 캐시 실패(캐시 미스) : 프로세서가 참조하려는 정보가 없을 때
- 블록의 크기는 캐시의 성능으로 좌우되는데, 실제 프로그램을 실행할 때 참조한 메모리에 대한 공간적 지역성과 시간적 지역성이 있기 때문
  - 공간적 지역성 : 대부분의 프로그램이 참조한 주소와 인접한 주소의 내용을 다시 참조하려는 특성
  - 시간적 지역성 : 한 번 참조한 주소를 곧 다시  참조하려는 특성
- 공간적 지역성과 시간적 지역성의 발생 원인
  - 프로그램이 명령어를 순차적으로 실행하려는 경향이 있어 명령어가 특정 지역 메모리에 인접해 있다.
  - 순환(단일 순환,  중첩 순환) 때문에 프로그램을 반복하더라도 메모리 일부 영역만 참조한다.
  - 대부분의 컴파일러를 메모리에 인접한 블록에 배열로 저장한다. 따라서 프로그램이 배열 원소에 순차적으로 자주 접근하므로 지역적인 배열 접근 경향이 있다.

> 지역성은 블록티 크면 캐시의 히트율이 올라갈 수 있음을 의미하지만,  블록이 커지면 이에 따른 전송 부담과 캐시 데이터 교체 작업이 자주 일어나므로 블록 크기를 무작정 늘릴 수는 없음.

```c
//공간적 지역성
main(){
    
}
//시간적 지역성
for (i=0;i<=n;i++){
    for(j=0;j<m;j++){
        x=x+(a[i][j]); // A
        or
        x=x+(a[j][i]); // B
    }
}
```



## 1장 02컴퓨터 시스템의 동작

### 명령어의 기본 구조

| 명령부   | 주소부    | 주소부    | 주소부 | 주소부 | 주소부     |
| :------- | --------- | --------- | ------ | ------ | ---------- |
| 연산부호 | 피연산자1 | 피연산자2 | ----   | ------ | 피연산자 n |

- **연산 부호 (OPcode)**
  - 프로세서가 실행할 동작인 연산 지정
  - 산술 연산, 논리 연산, 시프트, 보수 등 연산 정의
  - 연산 부호가 n비트이면 최대 2^n개 연산이 가능
- **피연산자(OPerand)**
  - 연산할 데이터 정보 저장
  - 데이터는 레지스터나 메모리, 가상 기억장치, 입출력장치 등에 위치할 수 있는데 보통 데이터 자체보다는 데이터의 위치 저장

![주석 2019-10-12 145332](https://user-images.githubusercontent.com/37978105/66697514-420ebd80-ed11-11e9-8eaa-6f8d297c9c12.png)



### 직접 주소와 간접 주소

- 피연산자의 위치를 명시하는 방법(직접 주소 또는 간접 주소)을 나타내는 모드 비트(mode bit) I를 추가하거나, 다음 명령어의 위치를 나타내는 주소를 추가 가능

- **직접 주소(direct address)**

  - 피연산자에 데이터가 있는 레지스터나 메모리 주소 지정

- **간접 주소(indirect address)**

  - 레지스터나 메모리 주소 정보 지정

  ![주석 2019-10-12 145745](https://user-images.githubusercontent.com/37978105/66697521-4dfa7f80-ed11-11e9-82b2-5b6abe8ffbce.png)





### 명령어의 실행 사이클

![주석 2019-10-12 150028](https://user-images.githubusercontent.com/37978105/66697529-5bb00500-ed11-11e9-9f6e-b87a34d91318.png)

### 인출 사이클(fetch cycle)

- 메모리에서 명령어를 읽어 명령어 레지스터에 저장하고, 다음 명령어를 실행하려고 프로그램 카운터를 증가시킴
- 인출 사이클에 소요되는 시간을 명령어 인출 시간이라고 함

### 실행 사이클(execution cycle)

- 인출한 명령어를 해독하고 그 결과에 따라 제어 신호를 발생시켜 명령어 실행
- 실행 사이클에서 소비되는 시간을 실행 시간이라고 함

### 간접 사이클(indirect cycle)

- 간접 주소 지정 방법을 사용하는 실행 사이클은 명령어를 수행하기 전에 실제 데이터가 저장된 주 기억장치의 주소인 유효 주소를 한 번 더 읽어 옴

### 인터럽트 사이클(interrupt cycle)

- 인터럽트 : 프로세서가 프로그램을 수행하는 동안 컴퓨터 시스템의 내부나 외부에서 발생하는 예기치 못한 사건
- 프로세서는 **실행 사이클을 완료한 후 인터럽트 요구가 있는지 검사.**인터럽트 요구가 없으면 다음 명령어를 인출하고, 인터럽트 요구가 있으면 현재 수행 중인 프로그램의 주소(프로그램 카운터) 값을 스택이나 메모리의 0번지와 같은 특정 장소에 저장. 프로그램 카운터에는 인터럽트 처리 루틴의 시작 주소를 저장해 두었다가 인터럽트 처리를 완료하면 중단된 프로그램으로 복귀하여 계속 수행

![주석 2019-10-12 153009](https://user-images.githubusercontent.com/37978105/66697535-68345d80-ed11-11e9-8745-9522b7effd86.png)

![주석 2019-10-12 153027](https://user-images.githubusercontent.com/37978105/66697542-75514c80-ed11-11e9-8e7d-ebcda6343134.png)

![주석 2019-10-12 153134](https://user-images.githubusercontent.com/37978105/66697545-80a47800-ed11-11e9-877d-02b6654b6236.png)



## 2장 01운영체제의 발전 과정과 유형

### 일괄 처리 시스템

- 1950년대에 계발된 초기 운영체제
  - 작업을 올리는 시간과 해제하는 시간 줄이는 데 관심(일괄 처리, 버퍼링, 스풀링 등 방법 도임)
- 일괄 처리
  - 일괄 처리는 직렬 처리 기술과 동일
  - 작업 준비 시간을 줄이려고 데이터가 발생할 때마다 즉시 처리하지 않고 데이터를 일정 기간 또는 일정량이 될 때까지 모아 두었다가 한꺼번에 처리
- 일괄 처리 장점
  - 많은 사용자와 프로그램이 컴퓨터 자원 공유
  - 컴퓨터 자원을 덜 사용 중일 때는 작업 처리 시간 교대 가능
  - 시시각각 수동으로 개입, 감독하여 컴퓨터 자원의 유휴 회피 가능

![주석 2019-10-12 154237](https://user-images.githubusercontent.com/37978105/66697553-8d28d080-ed11-11e9-9d0d-124d13bd47b2.png)

- 일괄 처리 단점
  - 준비 작업들의 유형이 동일해야 하고, 작업에 모든 유형의 입력 불가능
  - 입출력장치가 프로세서보다 **속도 느려** 프로세서의 유휴 상태 발생
  - 작업 우선순위 부여 관란.
  - 문제점 보완 위해 모니터링, 버퍼링, 스풀링 등 여러 방법 등장
- 버퍼링(buffering)
  - 유휴 시간이 없도록 입출력장치별로 입출력 버퍼 두어, 프로세서에서 연산 할 떄 동시에 다른 작업 입출력하는 아주 간단한 방법
- 스풀링(spooling)
  - 속도가 빠른 디스크를 버퍼처럼 사용 입출력장치에서 미리 읽는 것
  - 버퍼링이 컴퓨터 하드웨어의 일부인 버퍼를 사용 한다면, 스풀링은 별개의 오프라인 장치 사용
  - 버퍼링이 하나의 입출력 작업과 그 작업의 계산만 함께 할 수 있는 반면, 스풀링은 여러 작업의 입출력과 계산을 함께 할 수 있음
  - 프로세서에 일정한 디스크 공간, 테이블만 있으면 하나의 계산 작업과 다른 입출력 작업 중복 처리
  - 프로세서와 입출력장치가 고효율로 작업하게 함
  - 성능에 직접적으로 도움

### 다중 프로그래밍 시스템

- 프로세스가 다른 작업 수행 시 입출력 작업 불가능하여 프로세서와 메인 메모리의 활용도 떨어지는 일괄 처리 시스템의 큰 문제를 다중 프로그래밍 도입하여 해결
- 프로세서가 유휴 상태일 때 실행 중인 둘 이상의 작업이 프로세서를 전환 (인터리빙)하여 사용할 수 있도록 동작

![주석 2019-10-12 160429](https://user-images.githubusercontent.com/37978105/66697555-99ad2900-ed11-11e9-9059-ae7845e29584.png)

- 다중 프로그래밍의 특징

  - 높고 효율적인 프로세서 사용률(**효율적인 운영**) 증가
  - 많은 사용자의 프로그램이 거의 동시에 프로세서를 할당받는 듯한 느낌
  - 다중 프로그래밍 운영체제는 아주 복잡
  - 여러 작업을 준비 상태로 두려면 이를 메모리에 보관, 일정 형태의 메모리를 관리해야 함
  - 여러 작업이 수행할 준비를 갖추고 있으면, 이 중 하나를 선택하는 결정 방법 필요( 인터럽트 이용 수행하는 프로세서 스케줄링의 다중 프로그래밍으로, 현재 운영체제의 중심 주제)

  ![주석 2019-10-12 164920](https://user-images.githubusercontent.com/37978105/66697559-a3cf2780-ed11-11e9-8197-afd45ba59cbf.png)

